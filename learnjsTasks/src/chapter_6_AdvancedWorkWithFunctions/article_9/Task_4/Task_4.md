# Тормозящий (throttling) декоратор  <br/>

Создайте «тормозящий» декоратор throttle(f, ms), который возвращает обёртку,   <br/>
передавая вызов в f не более одного раза в ms миллисекунд.   <br/>
Те вызовы, которые попадают в период «торможения», игнорируются.  <br/>
Отличие от debounce – если проигнорированный вызов является последним   <br/>
во время «задержки», то он выполняется в конце.  <br/>

Давайте рассмотрим реальное применение, чтобы лучше понять это   <br/>
требование и выяснить, откуда оно взято.  <br/>

Например, мы хотим отслеживать движения мыши.  <br/>

В браузере мы можем объявить функцию, которая будет запускаться при   <br/>
каждом движении указателя и получать его местоположение.   <br/>
Во время активного использования мыши эта функция запускается очень часто,   <br/>
это может происходить около 100 раз в секунду (каждые 10 мс).  <br/>

Мы бы хотели обновлять информацию на странице при передвижениях.  <br/>

…Но функция обновления update() слишком ресурсоёмкая, чтобы делать   <br/>
это при каждом микродвижении. Да и нет смысла делать обновление чаще,   <br/>
чем один раз в 1000 мс.  <br/>

Поэтому мы обернём вызов в декоратор: будем использовать throttle(update, 1000)   <br/>
как функцию, которая будет запускаться при каждом перемещении указателя   <br/>
вместо оригинальной update(). Декоратор будет вызываться часто, но   <br/>
передавать вызов в update() максимум раз в 1000 мс.  <br/>

Визуально это будет выглядеть вот так:  <br/>

Для первого движения указателя декорированный вариант сразу передаёт вызов   <br/>
в update. Это важно, т.к. пользователь сразу видит нашу реакцию на его перемещение.  <br/>
Затем, когда указатель продолжает движение, в течение 1000 мс ничего не происходит.   <br/>
Декорированный вариант игнорирует вызовы.  <br/>
По истечению 1000 мс происходит ещё один вызов update с последними координатами.  <br/>
Затем, наконец, указатель где-то останавливается. Декорированный вариант ждёт,   <br/>
пока не истечёт 1000 мс, и затем вызывает update с последними координатами.   <br/>
В итоге окончательные координаты указателя тоже обработаны.  <br/>
Пример кода:  <br/>

function f(a) {  <br/>
console.log(a)  <br/>
}  <br/>

// f1000 передаёт вызовы f максимум раз в 1000 мс  <br/>
let f1000 = throttle(f, 1000);  <br/>

f1000(1); // показывает 1  <br/>
f1000(2); // (ограничение, 1000 мс ещё нет)  <br/>
f1000(3); // (ограничение, 1000 мс ещё нет)  <br/>

// когда 1000 мс истекли ...  <br/>
// ...выводим 3, промежуточное значение 2 было проигнорировано  <br/>
P.S. Аргументы и контекст this, переданные в f1000, должны быть   <br/>
переданы в оригинальную f.  <br/>